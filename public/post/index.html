<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Posts &middot; 郑印</title>

    <meta name="description" content="85后程序员，目前在写PHP和Nodejs">

    <meta name="generator" content="Hugo 0.14" />
    <meta name="twitter:card" content="summary">
    
    <meta name="twitter:title" content="Posts &middot; 郑印">
    <meta name="twitter:description" content="85后程序员，目前在写PHP和Nodejs">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Posts &middot; 郑印">
    <meta property="og:description" content="85后程序员，目前在写PHP和Nodejs">

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-old-ie-min.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">
    <!--<![endif]-->

    <link rel="stylesheet" href="http://localhost:1313//css/all.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="郑印" href="http://localhost:1313//index.xml" />
</head>
<body>


<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <hgroup>
            <h1 class="brand-title"><a href="http://localhost:1313/">郑印</a></h1>
            <h2 class="brand-tagline"> 85后程序员，目前在写PHP和Nodejs </h2>
        </hgroup>

        <nav class="nav">
            <ul class="nav-list">
                
                
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/zhengyin "><i class="fa fa-github-alt"></i> Github</a>
                </li>
                
                <li class="nav-item">
                    <a class="pure-button" href="http://localhost:1313//index.xml"><i class="fa fa-rss"></i> rss</a>
                </li>
            </ul>
        </nav>
    </div>
</div>


    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                
                <h1 class="content-subhead">01 Jan 0001, 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://localhost:1313/post/socketio-bid/" class="post-title">Socket.io的实时竞拍系统实现</a>

                        <p class="post-meta">
                            
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>某天张同学来到了一个拍卖网站，看中了一件心仪的拍品，于是他愉快的参与了竞价，并处于了领先的地位，随后张同学死死盯住拍品倒计时和领先者，在倒计时结束后发现领先者还是他自己，正当他欣喜若狂准备付款时，页面刷新发现拍品已被别人抢走。后来当张同学在次来到网站，便长了记性，开始无止境的F5~</p>

<p>当然我们不能这样折腾我们的用户，那么如何实现拍品信息实时更新？ 要解决这个需求，实际上需要服务端主动“推” 信息到客户端。而客户端想要得到服务端推送的信息，实际上需要和服务端建立一个长连接，这样服务端才能通过这个连接把信息传递到客户端，也就是所谓“推”的概念，下面有篇文章详细介绍了WEB推送的系统的客户端实现方式：</p>

<p><a href="http://www.ibm.com/developerworks/cn/web/wa-lo-comet/">Comet：基于 HTTP 长连接的“服务器推”技术</a></p>

<p>Nginx也有相应的模块进行服务端的支持：</p>

<p><a href="https://www.nginx.com/resources/wiki/modules/push_stream/">HTTP Push Stream</a></p>

<p>这里我们主要来说说通过Node平台下的Socket.io如何实现，首先来看下具体的业务场景是什么,一个最基本的实时竞拍系统应该包含以下三个场景：</p>

<ol>
<li>一个或者多个用户关注着某一个拍品</li>
<li>当其中某个用户出价后，更新数据库中该拍品的信息</li>
<li>将最新的拍品信息反应到关注该拍品用户的客户端上</li>
</ol>

<p>那么根据这三个场景，能够确认推送的一个大概思路，也就是 “当拍品出价成功后，取得最新的拍品信息，推送给关注该拍品的所有用户”，基于这个思路可以确定一个大概的推送流程图:</p>

<p><img src="http://upload-images.jianshu.io/upload_images/1639948-8c0ede3a86d71389.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="推送流程图.png" /></p>

<p>这个流程图中分为4个部分：</p>

<ul>
<li>客户端(接受推送消息，已经出价)</li>
<li>竞价接口(处理竞价逻辑，加入拍品到推送队列)</li>
<li>队列处理(取出需要推送的拍品调用推送API)</li>
<li>推送服务(提供socket.io的服务端供客户端进行</li>
</ul>

<p>连接，并提供一组推送的内网API供应用程序调用)</p>

<p>根据以上流程，竞价接口以及队列处理我们可以采用任意的语言去实现，这里不在延伸。这两部分中队列处理，根据具体业务可以省去，这里引入队列处理的目的主要是考虑到，推送服务本身与竞价流程解耦，以及当推送服务故障时，失败队列的维护,当然如果使用队列，也需要考虑队列处理的及时性，避免推送信息的不及时。</p>

<p>下面来看看推送服务如何构建:</p>

<p>(以下均是伪代码,只为说明具体思路)</p>

<pre><code>
      var http = require(&quot;http&quot;);
      http.globalAgent.maxSockets = Infinity;
      var koa = require('koa');
      var app = koa();
      var bodyParser = require('koa-bodyparser');
      var route = require('koa-route');
      var io = require('socket.io');
      var ioRedis = require('socket.io-redis');
      var ioEmitter = require('socket.io-emitter')({ host: '127.0.0.1', port: '6379' });
      var server = http.createServer(app.callback());

      io = io(server);

      io.adapter(ioRedis({ host :'127.0.0.1', prot :'6379'}));

      /**************  推送API ******************/
      app.use(bodyParser());
      app.use(route.post('/pub', function *(next){

          var data = this.request.body;

          if(!data || typeof data != 'object'){
              this.throw('data error', 400);
          }

          var room = data.itemId;
          var channel = data.channel;
          var message = data.message;

          ioEmitter.to(room).emit(channel,message);   

          this.body = 'ok';
          
      }));
      app.use(function *(){
        this.response.status = 404;
      })
      /*****************************************/

      /*************Socket.io Server ***********/
      io.use(function(socket,next){
          var itemId = socket.handshake.query.itemId;
          socket.room = itemId;
          return next();
      });
      io.on('connection',function(socket){
          socket.join(socket.room);
      });
      /*****************************************/




      server.listen(3000,function(){});

</code></pre>

<p>推送服务实际上起到的是一个中间层的作用，下面看下客户端与服务端如何和它配合：</p>

<ul>
<li>客户端代码</li>
</ul>

<pre><code>  &lt;script&gt;
    var socket = io('http://推送服务地址:3000?itemId=100');
    socket.on('auction', function (data) {
          //调用 Dom 更新拍品信息
    });
  &lt;/script&gt;
</code></pre>

<p>客户端在连接是指明了itemId(假设它是拍品ID),这样在推送服务能够对其进行房间的划分,也就是在 socket.join(socket.room) 的时候。</p>

<ul>
<li>服务端代码(PHP)</li>
</ul>

<pre><code>        
	private function http($data){
               /** 
                    $data = array(
                          'itemId'=&gt;100,            //指明推送拍品
                          'channel'=&gt;'auction',  //指明推送到的渠道
                          'message'=&gt;array( )  //最新的拍品信息
                    );
               */

		$server = $this-&gt;getServer();  // http://127.0.0.1:3000/pub
		$ch = curl_init();
		curl_setopt($ch, CURLOPT_URL, $server);
		curl_setopt($ch, CURLOPT_TIMEOUT, 3);
		curl_setopt($ch, CURLOPT_POSTFIELDS,http_build_query($data));
		curl_setopt($ch, CURLOPT_HEADER, 0);
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
		$response = curl_exec($ch);
		if(curl_errno($ch)){
			throw new \Exception('curl_error  '.curl_error($ch));
		}else{
			if(strtolower($response) == 'ok'){    
				curl_close($ch);
				return true;
			}else{
				throw new \Exception('response_error  '.$response);
		}
			}
		curl_close($ch);
		return false;
	}

</code></pre>

<p>服务端在推送时，调用 &ldquo;<a href="http://127.0.0.1:3000/pub&quot;">http://127.0.0.1:3000/pub&quot;</a> ，也就是有 koa 搭建的http推送API ，并传入想应格式的数据，指明推送的拍品，渠道，信息。这样在 koa 接受到请求后，调用    ioEmitter.to(room).emit(channel,message);    将信息推送到客户端，这样就走完了一个流程。</p>

<p>总结：</p>

<ul>
<li>实时推送实际上就是消息的发布/订阅，客户端是消息订阅方，服务端是消息的发布方</li>
<li>推送服务也就是消息发布/订阅的服务</li>
<li>推送与竞价可以是两套不同业务，应该考虑解耦</li>
<li>使用Socket.io做Web的实时推送，代码量小，可控性高</li>
</ul>

                    </div>
                </section>
                
                <h1 class="content-subhead">01 Jan 0001, 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://localhost:1313/post/yaf-framework/" class="post-title">Yaf 框架视频教程</a>

                        <p class="post-meta">
                            
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h1 id="yaf-框架视频教程:a35b09ceae5d32b3a4552009c03ede68">Yaf 框架视频教程</h1>

<p>Yaf是我很喜欢的一个PHP框架，也是我目前所在公司用的PHP框架，以前录制过一些视频课程，前段时间起心，想把Yaf也录制一下，同时也可以分享下工作中怎么去使用Yaf的，所以就有了这套视频。目前17课，课程我尽量简短，所以时间不会太长，这套课程适合一些刚使用PHP开发不久的同学，如果你已经工作几年了，Yaf手册应该会更节约你的时间。</p>

<h2 id="课程列表:a35b09ceae5d32b3a4552009c03ede68">课程列表</h2>

<ol>
<li><a href="http://bbs.houdunwang.com/thread-99589-1-1.html" target="_blank">Yaf介绍</a></li>
<li><a  href="http://bbs.houdunwang.com/thread-99590-1-1.html" target="_blank">使用vagrant 统一开发环境</a></li>
<li><a  href="http://bbs.houdunwang.com/thread-99591-1-1.html" target="_blank">Yaf的安装与ide配置</a></li>

<li><p><a  href="http://bbs.houdunwang.com/thread-99592-1-1.html" target="_blank">Yaf的nginx配置</a></p></li>

<li><p><a  href="http://bbs.houdunwang.com/thread-99593-1-1.html" target="_blank">Yaf运行流程</a></p></li>

<li><p><a  href="http://bbs.houdunwang.com/thread-99687-1-1.html" target="_blank">Yaf,Bootstarp介绍</a></p></li>

<li><p><a href="http://bbs.houdunwang.com/thread-99696-1-1.html" target="_blank">Yaf配置</a></p></li>

<li><p><a  href="http://bbs.houdunwang.com/thread-99697-1-1.html" target="_blank">Yaf类库的加载规则</a></p></li>

<li><p><a  href="http://bbs.houdunwang.com/thread-99698-1-1.html" target="_blank">Yaf模块与控制器</a></p></li>

<li><p><a href="http://bbs.houdunwang.com/thread-99699-1-1.html" target="_blank">Yaf路由</a></p></li>

<li><p><a  href="http://bbs.houdunwang.com/thread-99700-1-1.html" target="_blank">Yaf视图</a></p></li>

<li><p><a  href="http://bbs.houdunwang.com/thread-99701-1-1.html" target="_blank">Yaf请求与响应</a></p></li>

<li><p><a  href="http://bbs.houdunwang.com/thread-99702-1-1.html" target="_blank">Yaf模型的使用</a></p></li>

<li><p><a  href="http://bbs.houdunwang.com/thread-99703-1-1.html" target="_blank">使用Yaf过程中，目录结构的划分</a></p></li>

<li><p><a  href="http://bbs.houdunwang.com/thread-99854-1-1.html" target="_blank">使用Yaf过程中，保持开发模式的统一</a></p></li>

<li><p><a  href="http://bbs.houdunwang.com/thread-99875-1-1.html" target="_blank">在Yaf中定义内网接口，Yar的使用</a></p></li>

<li><p><a  href="http://bbs.houdunwang.com/thread-99900-1-1.html" target="_blank">在Yaf中使用命令行执行PHP</a></p></li>
</ol>

<p>###<a style="color:#ccc;" href="javascript:void(0);" target="_blank">下载整套视频教程</a></p>

<h2 id="相关资源下载:a35b09ceae5d32b3a4552009c03ede68">相关资源下载</h2>

<ul>
<li><a href="http://pan.baidu.com/s/1hqk3pcg" target="_blank">课程中使用的开发环境Box文件</a></li>
<li><a href="http://pan.baidu.com/s/1dD13CEt" target="_blank">课程中使用的源代码</a></li>
<li><a href="https://github.com/zhengyin/izhengyin-yaf-libs" target="_blank">博客所使用的Yaf类库</a></li>
</ul>

<h2 id="相关参考链接:a35b09ceae5d32b3a4552009c03ede68">相关参考链接</h2>

<ul>
<li><a href="http://www.laruence.com/manual/" target="_blank">Yaf手册</a></li>
<li><a href="http://php.net/manual/zh/book.yar.php" target="_blank">Yar手册</a></li>
<li><a href="http://www.laruence.com/2012/09/15/2779.html" target="_blank">Yar介绍博文</a></li>
<li><a href="http://segmentfault.com/a/1190000000264347" target="_blank">使用 Vagrant 打造跨平台开发环境</a></li>
</ul>

                    </div>
                </section>
                
                <h1 class="content-subhead">01 Jan 0001, 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://localhost:1313/post/mysql-master-slave/" class="post-title">mysql 主从复制，读写分离</a>

                        <p class="post-meta">
                            
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="mysql-主从复制-读写分离:f281d2723fb126937526c018d1f3d9eb">mysql 主从复制，读写分离</h2>

<p>主从复制简单很好理解，简单来说就是把一台机器上的数据同步到另一台机器上面去，而读写分离也就是我们在操作mysql的时候，写的操作与读的操作不在作用于同一台数据库上，降低单机压力。</p>

<p>首先我在本地装了三台虚拟机用于测试,它们的主机名和IP地址如下。</p>

<pre><code> master   192.168.0.121        [ubuntu]
 slave1   192.168.0.131        [debian]
 slave2   192.168.0.141        [debian]
</code></pre>

<p>myql版本： 5.5</p>

<p>以下关于mysql复制的一些内容摘自《高性能mysql》 一书，如果你对细节感兴趣，你可购买此书进行查阅。</p>

<p>###MYSQL主从复制</p>

<p>#####复制解决的问题</p>

<pre><code>1.数据分布
2.负载均衡
3.备份
4.高可用性和故障切换
5.mysql升级测试
</code></pre>

<p>#####复制如何工作
    1.在主库上把数据更改记录到二进制日志(Binary Log)中(这些记录被称为二进制日志事件)。
    2.备库将主库上的日志复制到自己的中继日志(Relay Log)中。
    3.备库读取中继日志中的事件，将其重放到备库数据之上。</p>

<p>#####复制配置</p>

<p>######1.创建复制账号
在主库上创建复制账号,在mysql终端中键入如下命令即可
<pre>
</code>
GRANT REPLICATION SLAVE  , REPLICATION  CLIENT ON <em>.</em> TO slave1 @&ldquo;192.168.0.131&rdquo;  IDENTFIED BY &ldquo;password&rdquo; ;
</code>
</pre>
配置完成后在 从库上 连接下主库，避免后面出现一些不必要的麻烦,如同下面这样。</p>

<pre><code>mysql -h192.168.0.121 -uslave1 -p&quot;password&quot;
</code></pre>

<p>如果连接不成功，检查下主服务器上是否开放了对外连接，通常是防火墙设置问题。</p>

<p>######2.配置主库和备库
<pre>
    <code><br />
主库配置：<br />
[mysqld]
server-id = 121            //保证唯一性，这里我取 ip 的最后几位
log_bin = /data/mysql/logs/mysql-bin  // 二进制日志存放位置
    </code>
</pre><br />
 配置完成后从启主库，进入终端键入命令</p>

<pre><code>mysql&gt; show master status;
+------------------+----------+--------------+------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| mysql-bin.000011 |     236 |              |                  |
+------------------+----------+--------------+------------------+                 
留意下 File  ,Position 一会要用到，其中 File 是二进制日志名， Posttion 是数据点的位置
</code></pre>

<p>######从库配置:
<pre>
    <code><br />
主库配置：<br />
[mysqld]
server-id = 131
log_bin = /data/mysql/logs/mysql-bin
relay_log = /data/mysql/logs/mysql-relay-bin    //中继日志
log_slave_updates = 1    //允许备库将其重放的事件也记录到自身二进制日志中
read_only = 1        //只读
    </code>
</pre></p>

<p>######3.启动复制
从库配置完后重启下mysql，进入终端[从库],键入如下命令:
<pre><code>
mysql&gt; CHANGE MASTER TO MASTER_HOST=&lsquo;192.168.0.121&rsquo;,
    -&gt; MASTER_USER=&lsquo;slave1&rsquo;,
    -&gt; MASTER_PASSWORD=&lsquo;password&rsquo;,
    -&gt; MASTER_LOG_FILE=&lsquo;mysql-bin.000011&rsquo;,
    -&gt; MASTER_LOG_POS=0;
 #MASTER_LOG_FILE 指定主库二进制日志文件
 #MASTER_LOG_POS 指定复制开始的位置
</code></pre>
这一步完成后，下面这个命令查看从库状态
<pre><code>
mysql&gt; SHOW SLAVE STATUS\G;
*************************** 1. row ***************************
       Slave_IO_State:
        &hellip;&hellip;&hellip;.
       Slave_IO_Running: No
       Slave_SQL_Running: No
       &hellip;&hellip;&hellip;.
</code></pre>
这几个地方显示着我们的复制还未开始,接下来启动复制.
<pre><code>
mysql&gt; START SLAVE;
mysql&gt; SHOW SLAVE STATUS\G;
*************************** 1. row **************************
 Slave_IO_State: Waiting for master to send event
 Slave_IO_Running: Yes
 Slave_SQL_Running: Yes
</code></pre>
这样复制就开始运行了 ,创建一些数据测试下，下面的SQL就不解释了。
主库：
<pre><code>
mysql&gt; create database test charset utf8;
Query OK, 1 row affected (0.00 sec)</p>

<p>mysql&gt; use test
Database changed
mysql&gt; create table user (uid int unsigned not null primary key auto_increment,name char(40) not null default &ldquo;);
Query OK, 0 rows affected (0.01 sec)</p>

<p>mysql&gt; insert into user set name=&lsquo;szws01&rsquo;;
Query OK, 1 row affected (0.00 sec)</p>

<p>mysql&gt; select * from user;
+&mdash;&ndash;+&mdash;&mdash;&ndash;+
| uid | name   |
+&mdash;&ndash;+&mdash;&mdash;&ndash;+
|   1 | szws01 |
+&mdash;&ndash;+&mdash;&mdash;&ndash;+
1 row in set (0.00 sec)
</code></pre>
从库：
<pre><code>
mysql&gt; use test
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A</p>

<p>Database changed
mysql&gt; show tables;
+&mdash;&mdash;&mdash;&mdash;&mdash;-+
| Tables_in_test |
+&mdash;&mdash;&mdash;&mdash;&mdash;-+
| user           |
+&mdash;&mdash;&mdash;&mdash;&mdash;-+
1 row in set (0.00 sec)</p>

<p>mysql&gt; select * from user;
+&mdash;&ndash;+&mdash;&mdash;&ndash;+
| uid | name   |
+&mdash;&ndash;+&mdash;&mdash;&ndash;+
|   1 | szws01 |
+&mdash;&ndash;+&mdash;&mdash;&ndash;+
1 row in set (0.00 sec)
</code></pre></p>

<p>自此主从就配置完成了，当然这个配置很简单，这是基于主服务器，与从服务器都是新安装的mysql来的。</p>

<p>###使用Amoeba做读写分离</p>

<p>######AMOEBA是什么
   • 专注于分布式数据库代理层（ Database Proxy） 开发</p>

<p>• 座落与 Client、 service之间,对客户端透明</p>

<p>• 具有负载均衡、高可用性、可路由相关请求到目标数据库、 可并发请求多台数 据库合并结果</p>

<p>• 通过Amoeba你能够完成多数据源的高可用、负载均衡、数据切片的功能</p>

<p>######读写分离结构图</p>

<p><img src="http://izhengyin.com/static/images/01.jpg" alt="Mou icon" /></p>

<p>######准备工作</p>

<pre><code>    在线文档: http://docs.hexnova.com/amoeba/       
    下载地址：http://sourceforge.net/projects/amoeba/files/
    本文使用的版本是： amoeba-mysql-binary-2.2.0[点击可下载]
    使用之前需要安装 java jdk ,本文使用的是 jdk1.7
    Amoeba安装很简单
            1.下载对应的版本
            2.解压到安装目录,本文解压到了 /opt/app/amoeba
            3.进入   /opt/app/amoeba/bin  执行命令:
                 ➜  bin  pwd
                 /opt/app/amoeba/bin
                 ➜  bin  ./amoeba
                 amoeba start|stop
                 看到以上信息就成了，这里我为了方便把该目录加到环境变量PATH里：
                 vim ~/.zshrc
                 export PATH=&quot;$JAVA_HOME/bin:/usr/local/sbin:/opt/app/amoeba/bin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/mysql/bin&quot; 
                 source ~/.zshrc     #根据你的shell而定
</code></pre>

<p>######Amoeba主从配置
        Amoeba 主要有三个配置文件
                1.dbServers.xml            //配置一些集群上mysql的数据库连接参数
                2.amoeba.xml              //Amoeba自身的配置，主机，端口，账号，密码,以及如何加载server,rule等。
                3.rule.xml                     //路由配置，主要是数据切片的一些配置，读写分离这块可以不用。
                配置文件放在   /opt/app/amoeba/conf/ 下。
               xml的配置文件看起来有些乱，看横线分割部分吧。</p>

<p>dbServers.xml 配置</p>

<pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;gbk&quot;?&gt; 

    &lt;!DOCTYPE amoeba:dbServers SYSTEM &quot;dbserver.dtd&quot;&gt; 
    &lt;amoeba:dbServers xmlns:amoeba=&quot;http://amoeba.meidusa.com/&quot;&gt; 
    &lt;dbServer name=&quot;abstractServer&quot; abstractive=&quot;true&quot;&gt; 
    &lt;factoryConfig class=&quot;com.meidusa.amoeba.mysql.net.MysqlServerConnectionFactory&quot;&gt; 
    &lt;property name=&quot;manager&quot;&gt;${defaultManager}&lt;/property&gt;
    &lt;property name=&quot;sendBufferSize&quot;&gt;64&lt;/property&gt;
    &lt;property name=&quot;receiveBufferSize&quot;&gt;128&lt;/property&gt;

    &lt;!-- mysql 连接主配置  --&gt;

    &lt;property name=&quot;port&quot;&gt;3306&lt;/property&gt;
    &lt;property name=&quot;schema&quot;&gt;test&lt;/property&gt;
    &lt;!-- mysql user --&gt;
    &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;
    &lt;!-- mysql password --&gt;
    &lt;property name=&quot;password&quot;&gt;password&lt;/property&gt;



    &lt;/factoryConfig&gt; 
    &lt;poolConfig class=&quot;com.meidusa.amoeba.net.poolable.PoolableObjectPool&quot;&gt; 
    &lt;property name=&quot;maxActive&quot;&gt;500&lt;/property&gt;
    &lt;property name=&quot;maxIdle&quot;&gt;500&lt;/property&gt;
    &lt;property name=&quot;minIdle&quot;&gt;10&lt;/property&gt;
    &lt;property name=&quot;minEvictableIdleTimeMillis&quot;&gt;600000&lt;/property&gt;
    &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot;&gt;600000&lt;/property&gt;
    &lt;property name=&quot;testOnBorrow&quot;&gt;true&lt;/property&gt;
    &lt;property name=&quot;testOnReturn&quot;&gt;true&lt;/property&gt;
    &lt;property name=&quot;testWhileIdle&quot;&gt;true&lt;/property&gt;
    &lt;/poolConfig&gt; 
    &lt;/dbServer&gt; 

    &lt;!-- 单个 server 配置 ,账号密码继承了主配置 --&gt;
    &lt;dbServer name=&quot;master&quot; parent=&quot;abstractServer&quot;&gt; 
    &lt;factoryConfig&gt;
    &lt;property name=&quot;ipAddress&quot;&gt;192.168.0.121&lt;/property&gt;
    &lt;/factoryConfig&gt;
    &lt;/dbServer&gt; 
    &lt;dbServer name=&quot;slave1&quot; parent=&quot;abstractServer&quot;&gt;
    &lt;factoryConfig&gt;
    &lt;property name=&quot;ipAddress&quot;&gt;192.168.0.131&lt;/property&gt;
    &lt;/factoryConfig&gt;
    &lt;/dbServer&gt; 
    &lt;dbServer name=&quot;slave2&quot; parent=&quot;abstractServer&quot;&gt;
    &lt;factoryConfig&gt;
    &lt;property name=&quot;ipAddress&quot;&gt;192.168.0.141&lt;/property&gt;
    &lt;/factoryConfig&gt;
    &lt;/dbServer&gt;

    &lt;!-- 单独为从库进行区分,按照 ROUNDROBIN  做负载均衡--&gt;
    &lt;dbServer name=&quot;virtualSlave&quot; virtual=&quot;true&quot;&gt; 
    &lt;poolConfig class=&quot;com.meidusa.amoeba.server.MultipleServerPool&quot;&gt;
    &lt;!-- Load balancing strategy: 1=ROUNDROBIN , 2=WEIGHTBASED , 3=HA--&gt;
    &lt;property name=&quot;loadbalance&quot;&gt;1&lt;/property&gt;
    &lt;!-- Separated by commas,such as: server1,server2,server1 --&gt;
    &lt;property name=&quot;poolNames&quot;&gt;slave1,slave2&lt;/property&gt;
    &lt;/poolConfig&gt;
    &lt;/dbServer&gt;
    &lt;/amoeba:dbServers&gt; 
</code></pre>

<p>amoeba.xml 配置</p>

<pre><code>    &lt;!-- service class must implements com.meidusa.amoeba.service.Service --&gt;
    &lt;service name=&quot;Amoeba for Mysql&quot; class=&quot;com.meidusa.amoeba.net.ServerableConnectionManager&quot;&gt;
            &lt;!--- 连接的ip和端口  ---&gt;

            &lt;!-- port --&gt;
            &lt;property name=&quot;port&quot;&gt;8066&lt;/property&gt;
            &lt;!-- bind ipAddress --&gt;
            &lt;property name=&quot;ipAddress&quot;&gt;127.0.0.1&lt;/property&gt;


            &lt;property name=&quot;manager&quot;&gt;${clientConnectioneManager}&lt;/property&gt;

            &lt;property name=&quot;connectionFactory&quot;&gt;
                    &lt;bean class=&quot;com.meidusa.amoeba.mysql.net.MysqlClientConnectionFactory&quot;&gt;
                            &lt;property name=&quot;sendBufferSize&quot;&gt;128&lt;/property&gt;
                            &lt;property name=&quot;receiveBufferSize&quot;&gt;64&lt;/property&gt;
                    &lt;/bean&gt;
            &lt;/property&gt;

            &lt;property name=&quot;authenticator&quot;&gt;
                    &lt;bean class=&quot;com.meidusa.amoeba.mysql.server.MysqlClientAuthenticator&quot;&gt;

           &lt;!--- 连接的用户与密码 ---&gt;
                            &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;

                            &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;

                            &lt;property name=&quot;filter&quot;&gt;
                                    &lt;bean class=&quot;com.meidusa.amoeba.server.IPAccessController&quot;&gt;
                                            &lt;property name=&quot;ipFile&quot;&gt;${amoeba.home}/conf/access_list.conf&lt;/property&gt;
                                    &lt;/bean&gt;
                            &lt;/property&gt;
                    &lt;/bean&gt;
            &lt;/property&gt;

    &lt;/service&gt;

    .................................

    &lt;queryRouter class=&quot;com.meidusa.amoeba.mysql.parser.MysqlQueryRouter&quot;&gt;

            &lt;property name=&quot;ruleLoader&quot;&gt;
                    &lt;bean class=&quot;com.meidusa.amoeba.route.TableRuleFileLoader&quot;&gt;
                            &lt;property name=&quot;ruleFile&quot;&gt;${amoeba.home}/conf/rule.xml&lt;/property&gt;
                            &lt;property name=&quot;functionFile&quot;&gt;${amoeba.home}/conf/ruleFunctionMap.xml&lt;/property&gt;
                    &lt;/bean&gt;
            &lt;/property&gt;

            &lt;property name=&quot;sqlFunctionFile&quot;&gt;${amoeba.home}/conf/functionMap.xml&lt;/property&gt;
            &lt;property name=&quot;LRUMapSize&quot;&gt;1500&lt;/property&gt;
            &lt;property name=&quot;defaultPool&quot;&gt;master&lt;/property&gt;
            &lt;!-- 读写配置 --&gt;
            &lt;property name=&quot;writePool&quot;&gt;master&lt;/property&gt;
            &lt;property name=&quot;readPool&quot;&gt;virtualSlave&lt;/property&gt;

            &lt;property name=&quot;needParse&quot;&gt;true&lt;/property&gt;
    &lt;/queryRouter&gt;
</code></pre>

<p>启动Amoeba ：</p>

<pre><code>➜  conf  amoeba start
log4j:WARN log4j config load completed from file:/opt/app/amoeba/conf/log4j.xml
  2015-01-11 15:19:17,732 INFO  context.MysqlRuntimeContext - Amoeba for Mysql current versoin=5.1.45-mysql-amoeba-proxy-2.2.0
  log4j:WARN ip access config load completed from file:/opt/app/amoeba/conf/access_list.conf
  2015-01-11 15:19:18,053 INFO  net.ServerableConnectionManager - Amoeba for Mysql listening on /127.0.0.1:8066.
  2015-01-11 15:19:18,059 INFO  net.ServerableConnectionManager - Amoeba Monitor Server listening on /127.0.0.1:894.
</code></pre>

<p>打开一个新终端,连接Amoeba:</p>

<pre><code>➜  amoeba  mysql -h127.0.0.1 -uroot -p123456 -P8066
   Welcome to the MySQL monitor.  Commands end with ; or \g.
   Your MySQL connection id is 1226617162
   Server version: 5.1.45-mysql-amoeba-proxy-2.2.0 Source distribution

   Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.

   Oracle is a registered trademark of Oracle Corporation and/or its
   affiliates. Other names may be trademarks of their respective
   owners.

   Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

   mysql&gt;
</code></pre>

<p>看起来和正常进入mysql一样，你可以通过    Server version 区分它与mysql，下面做一些操作测试，怎样使用mysql怎样使用它。</p>

<pre><code>mysql&gt; show databases;
    +--------------------+
    | Database           |
    +--------------------+
    | information_schema |
    | logs               |
    | mysql              |
    | performance_schema |
    | test               |
    +--------------------+
    5 rows in set (0.00 sec)
    mysql&gt; use test
    Database changed
    mysql&gt; select * from user;
    +-----+--------+
    | uid | name   |
    +-----+--------+
    |   1 | szws01 |
    +-----+--------+
    1 row in set (0.00 sec)
    mysql&gt;
</code></pre>

<p>可以看到和我们之前数据是一样的，接下来测试下读写分离。</p>

<p>1.停掉从库 ,在 slave1 slave2 终端键入:</p>

<pre><code>    STOP SLAVE;                  
</code></pre>

<p>2.在Amoeba 终端写入数据,然后在查询.</p>

<pre><code>    mysql&gt; insert into user set name ='Amoeba';
    Query OK, 1 row affected (0.00 sec)

    mysql&gt; select * from user;
    +-----+--------+
    | uid | name   |
    +-----+--------+
    |   1 | szws01 |
    +-----+--------+
    1 row in set (0.00 sec)
</code></pre>

<p>查询发现刚才的数据找不到了，别着急我们去主库找找。</p>

<pre><code>➜  amoeba  mysql -uroot -p                        
Enter password:
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 20
Server version: 5.5.41-log Source distribution

Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&gt; use test
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql&gt; select * from user;
+-----+--------+
| uid | name   |
+-----+--------+
|   1 | szws01 |
|   2 | Amoeba |
+-----+--------+
2 rows in set (0.00 sec)
</code></pre>

<p>因为我们刚才关闭了主从，所以主库的数据并没有同步到从库，然而我们配置Amoeba的时候，设置了读是从 slave1,slave2上面读的，
所以没有查询到是正常的，接下来打开主从，slave1,slave2 执行命令:</p>

<pre><code>START SLAVE;
</code></pre>

<p>然后在 Amoeba 终端中查询：</p>

<pre><code>mysql&gt; select * from user;
+-----+--------+
 | uid | name   |
 +-----+--------+
 |   1 | szws01 |
 |   2 | Amoeba |
 +-----+--------+
 2 rows in set (0.00 sec)
</code></pre>

<p>现在有结果了，至此这篇文章就结束了，总体来说，不论是mysql主从还是Amoeba配置都是比较简单的。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">01 Jan 0001, 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://localhost:1313/post/mongodb-note/" class="post-title">php操作mongodb笔记</a>

                        <p class="post-meta">
                            
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>大致把它分为了如下几块记录</p>

<ul>
<li><a href="https://github.com/zhengyin/blog/blob/master/code/php-mongo/curd.php" target="_blank">Mongodb CURD 操作</a></li>
<li><a href="https://github.com/zhengyin/blog/blob/master/code/php-mongo/find.php" target="_blank">Mongodb 查询</a></li>
<li><a href="https://github.com/zhengyin/blog/blob/master/code/php-mongo/modify.php" target="_blank">Mongodb 修改器操作</a></li>
<li><a href="https://github.com/zhengyin/blog/blob/master/code/php-mongo/update.php" target="_blank">Mongodb 更多有关更新的内容</a></li>
<li><a href="https://github.com/zhengyin/blog/blob/master/code/php-mongo/cursor.php" target="_blank">Mongodb 游标操作</a></li>
</ul>

<p>每一个对应一个类文件,你可以点以上链接查看到源码。</p>

<p>测试的时候根据 GET 里面的 act 执行具体的方法，具体代码如下面这样。</p>

<pre><code>$act = isset($_GET['act'])?$_GET['act']:'read';
$o = new MongoDbCursor();
$o-&gt;$act();
</code></pre>

<p>目前只更新到游标部分，后续有更新我会继续在此帖补充。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">01 Jan 0001, 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://localhost:1313/post/php-process-manage-script/" class="post-title">写一个PHP进程管理脚本</a>

                        <p class="post-meta">
                            
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="写一个php进程管理脚本:d023dbfb12a7f9e4fc02119184930127">写一个PHP进程管理脚本</h2>

<p>进程管理脚本有Shell干嘛非要去折腾个PHP呢，这个问题让我来回答我会这样说。</p>

<p>用PHP来写很爽好吗，而且如果你的应用程序是PHP，这样会更灵活。总该为折腾找个理由，以上便是。</p>

<p>废话不多说，咱开始. 首先准备一些基础知识</p>

<p>###Shell部分</p>

<pre><code>1.如何后台运行一个PHP脚本，格式如下  &quot;PHP执行路径  脚本路径  &gt;&gt; 日志路径  &amp; &quot; 如：/opt/app/php/bin/php worker.php &gt;&gt; /tmp/log.log &amp; 
2.查看进程：&quot;ps aux | grep worker.php | grep -v grep&quot;   (跟着上面的例子)
3.取得进程PID: &quot;ps aux | grep worker.php | grep -v grep | awk '{print $2}'&quot; 
4.杀死一个进程: kill -9 {Pid}
</code></pre>

<p>###PHP部分</p>

<pre><code>1.PHP执行Shell函数： shell_exec($cmd);  $cmd 就是Shell命令 返回Shell输出流
2.直接在PHP脚本中执行Shell: `ps aux | grep worker.php`  返回Shell输出流
</code></pre>

<p>有了上面这些基础，下面的代码就比较简单了</p>

<p>###程序代码部分 WorkerAdmin.php</p>

<pre><code>
	&lt;?php
	/**
	 * @date 2015-07-17
	 * @author zhengyin &lt;zhengyin.name@gmail.com&gt;
	 * PHP 进程管理脚本
	 */
	class WorkerAdmin{
		
		const PHP_BIN = '/opt/app/php/bin/php';
		
		private static $process;
		
		private static $log;
		
		private static $num;
		
		private static $cmds = array('start','restart','stop');
		/**
		 * @param Array $argv
		 */
		public static function main($argv){
			
			self::$process = isset($argv[1])?$argv[1]:'';
		
			$cmd = isset($argv[2])?$argv[2]:'';
			
			self::$num = isset($argv[3])?intval($argv[3]):0;
	
			self::$log = isset($argv[4])?$argv[4]:'/dev/null';	//默认丢弃日志
			//脚本不存在，或者不可执行
			if(!file_exists(self::$process) || !is_executable(self::$process)){
				echo self::$process.&quot; not exists\n&quot;;
				echo chr(7);
				exit;
			}
			//cmd 不正确
			if(!in_array($cmd, self::$cmds)){
				echo &quot;usage: &quot;.self::$process.&quot; &quot;.implode('|', self::$cmds).&quot; [num]\n&quot;;
				echo chr(7);
				exit;
			}
			
			self::$cmd();
		}
		/**
		 * 启动
		 */
		public static function start(){
			if(self::$num&lt;1){
				echo &quot;start num is invalid\n&quot;;
				echo chr(7);
				exit;
			}else{
				for ($i=0;$i&lt;self::$num;$i++){
					self::runWorker();
				}
				echo &quot;start done\n&quot;;
			}
		}
		/**
		 * 重启
		 */
		public static function restart(){
			$count = 0;
			$pids = self::getWorkerPids();
			for($i=0;$i&lt;count($pids);$i++){
				self::killWorker($pids[$i]);
				//杀掉老进程后，新启一个进程
				$count++;
				self::runWorker();
				//缓冲1秒，避免瞬间杀死worker后，照成脚本无法工作
				sleep(1);
			}
			//最后检查下，是否达到了需要的启动数量
			if($count &lt;self::$num){
				for($n=0;$n&lt;self::$num-$count;$n++){
					self::runWorker();
				}
			}
			echo &quot;restart done\n&quot;;
		}
		/**
		 * 停止
		 */
		public static function stop(){
			$pids = self::getWorkerPids();
			for ($i=0;$i&lt;count($pids);$i++){
				self::killWorker($pids[$i]);
				//缓冲1秒，避免瞬间杀死worker后，照成脚本无法工作
				sleep(1);	
			}
			echo &quot;stop done\n&quot;;
		}
		/**
		 * 运行一个 worker
		 */
		private static function runWorker(){
			$cmd = sprintf(&quot;%s %s &gt;&gt; %s &amp;&quot;,self::PHP_BIN,self::$process,self::$log);
			echo $cmd.PHP_EOL;
			shell_exec($cmd);
		}
		/**
		 * 杀死一个 worker
		 */
		private static function killWorker($pid){
			`kill -9 $pid`;
			echo &quot;kill {$pid} done \n&quot;;
		}
		/**
		 * 获取正在运行的worker pid 
		 */
		private static function getWorkerPids(){
			
			$cmd = 'ps aux | grep '.basename(self::$process).'| grep -v grep | grep -v '.basename(__FILE__).' | awk \'{print $2}\'';
			$result = shell_exec($cmd);
			$pids = array_filter(explode(&quot;\n&quot;, $result));
			return $pids;
		}
	}
	WorkerAdmin::main($argv);

</code></pre>

<p>在同级目录建立一个测试文件： worker.php 代码如下</p>

<pre><code>
	&lt;?php
	while (true){
		echo date('Y-m-d H:i:s').PHP_EOL;
		sleep(3);
	}

</code></pre>

<p>如果要对该 Worker 进行管理命令如下:</p>

<pre><code>php WorkerAdmin.php worker.php start 10  启动10个进程，无日志
php WorkerAdmin.php worker.php restart  重启
php WorkerAdmin.php worker.php stop  停止
</code></pre>

<p>实际上如果你的守护进程和你的应用程序息息相关,完全可以走配置的文件进行更好的管理,这需要修改下 WorkerAdmin</p>

<p>###修改后的 WorkerAdmin.php</p>

<pre><code>
	&lt;?php
	/**
	 * @date 2015-07-17
	 * @author zhengyin &lt;zhengyin.name@gmail.com&gt;
	 * PHP 进程管理脚本
	 */
	class WorkerAdmin{
		
		const PHP_BIN = '/opt/app/php/bin/php';
		
		private static $workerConfig = array(
				'worker'=&gt;array(
					'process'=&gt;'/data/webroot/izhengyin/public/test/shell/worker.php',
					'num'=&gt;10,
					'log'=&gt;'/tmp/worker.log'		
				)
		);
		
		private static $process;
		
		private static $log;
		
		private static $num;
		
		private static $cmds = array('start','restart','stop');
		/**
		 * @param Array $argv
		 */
		public static function main($argv){
			
			$name = isset($argv[1])?$argv[1]:'';
			$cmd = isset($argv[2])?$argv[2]:'';
			
			//worker不存在
			if(!isset(self::$workerConfig[$name])){
				echo 'Worker:'.$name.&quot; not exists\n&quot;;
				echo chr(7);
				exit;
			}
			//取得相应的进程配置
			self::$process = self::$workerConfig[$name]['process'];
			self::$num = self::$workerConfig[$name]['num'];
			self::$log = self::$workerConfig[$name]['log'];
			
			//脚本不存在，或者不可执行
			if(!file_exists(self::$process) || !is_executable(self::$process)){
				echo self::$process.&quot; not exists\n&quot;;
				echo chr(7);
				exit;
			}
			//cmd 不正确
			if(!in_array($cmd, self::$cmds)){
				echo &quot;usage: &quot;.self::$process.&quot; &quot;.implode('|', self::$cmds).&quot; [num]\n&quot;;
				echo chr(7);
				exit;
			}
			
			self::$cmd();
		}
		/**
		 * 启动
		 */
		public static function start(){
			if(self::$num&lt;1){
				echo &quot;start num is invalid\n&quot;;
				echo chr(7);
				exit;
			}else{
				for ($i=0;$i&lt;self::$num;$i++){
					self::runWorker();
				}
				echo &quot;start done\n&quot;;
			}
		}
		/**
		 * 重启
		 */
		public static function restart(){
			$count = 0;
			$pids = self::getWorkerPids();
			for($i=0;$i&lt;count($pids);$i++){
				self::killWorker($pids[$i]);
				//杀掉老进程后，新启一个进程
				$count++;
				self::runWorker();
				//缓冲1秒，避免瞬间杀死worker后，照成脚本无法工作
				sleep(1);
			}
			//最后检查下，是否达到了需要的启动数量
			if($count &lt;self::$num){
				for($n=0;$n&lt;self::$num-$count;$n++){
					self::runWorker();
				}
			}
			echo &quot;restart done\n&quot;;
		}
		/**
		 * 停止
		 */
		public static function stop(){
			$pids = self::getWorkerPids();
			for ($i=0;$i&lt;count($pids);$i++){
				self::killWorker($pids[$i]);
				//缓冲1秒，避免瞬间杀死worker后，照成脚本无法工作
				sleep(1);	
			}
			echo &quot;stop done\n&quot;;
		}
		/**
		 * 运行一个 worker
		 */
		private static function runWorker(){
			$cmd = sprintf(&quot;%s %s &gt;&gt; %s &amp;&quot;,self::PHP_BIN,self::$process,self::$log);
			echo $cmd.PHP_EOL;
			shell_exec($cmd);
		}
		/**
		 * 杀死一个 worker
		 */
		private static function killWorker($pid){
			`kill -9 $pid`;
			echo &quot;kill {$pid} done \n&quot;;
		}
		/**
		 * 获取正在运行的worker pid 
		 */
		private static function getWorkerPids(){
			
			$cmd = 'ps aux | grep '.basename(self::$process).'| grep -v grep | grep -v '.basename(__FILE__).' | awk \'{print $2}\'';
			$result = shell_exec($cmd);
			$pids = array_filter(explode(&quot;\n&quot;, $result));
			return $pids;
		}
	}
	WorkerAdmin::main($argv);

</code></pre>

<p>下面你就可以通过如下命令管理Worker了:</p>

<pre><code>php WorkerAdmin.php worker start 启动worker
php WorkerAdmin.php worker restart  重启
php WorkerAdmin.php worker stop  停止
</code></pre>

<p>程序里面的 WorkerConfig 你完全可以把它摘除到外部，比如你使用框架，你可以把摘除到你的应用配置里，这里就不展开讨论了。</p>

<p>So , 这篇文章就到此为止。</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">01 Jan 0001, 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://localhost:1313/post/yaf-yar/" class="post-title">在Yaf中使用Yar</a>

                        <p class="post-meta">
                            
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h2 id="在yaf中使用yar:7ca2c6e4bdcb04df6c1f3d2a41a1f959">在Yaf中使用Yar</h2>

<p>本文提到的两个东西，都是 PHP 大神 惠新宸 的作品。</p>

<p>Yaf: PHP MVC框架  <a href="http://php.net/manual/zh/book.yaf.php">http://php.net/manual/zh/book.yaf.php</a></p>

<p>Yar: PHP RPC框架    <a href="http://php.net/manual/zh/book.yar.php">http://php.net/manual/zh/book.yar.php</a></p>

<p>看着篇文章之前你需要 Yaf,Yar 有所了解。</p>

<p>随着网站的发展，原本的系统会逐渐的实现细分，而细分的系统之间并不是全无关联，这就涉及到各系统之前数据传输问题，Yar 就是帮助我们解决这些问题的。</p>

<p>虽然 Yar已经把底层数据传输给我们解决了，并且调用十分简单,但要部署上线还是需要自行处理一些问题的，所谓“师傅领进门，修行靠个人”。</p>

<p>大致来说我们要解决下面这三个问题：</p>

<pre><code>1.数据传输安全校验
2.接口定义
3.数据格式
</code></pre>

<p>本文是我在 Yaf 处理这些问题的一些做法，如果你阅读完本文后有不同想法可以在评论区给我留言。</p>

<p>先贴出目录结构方便后面对应文字描述：</p>

<pre><code>➜  izhengyin  tree
.
├── application
│   ├── Bootstrap.php
│   ├── controllers
│   │   ├── Api.php
│   │   ├── Error.php
│   │   └── Index.php
│   ├── library
│   │   └── Api
│   │       ├── Order.php
│   │       └── User.php
│   ├── models
│   ├── modules
│   │   └── Api
│   │       └── controllers
│   │           └── User.php
│   ├── plugins
│   │   └── Runtime.php
│   └── views
│       ├── error
│       │   └── error.phtml
│       └── index
│           └── index.phtml
├── conf
│   └── application.ini
├── libs
│   └── IZY
│       └── Sys
│           ├── ApiClient.php
│           └── ApiServer.php
└── public
    └── index.php
</code></pre>

<p>首先来定义服务端，定义之前考虑下，一个系统可能会为不同的模块单独定义不同的接口类</p>

<p>比如一个电商系统，有会员模块，和订单模块，所以在定义接口时，把它们区分开来分开定义，所以把每一类的接口抽象为一个Server，定义如下。</p>

<p>会员接口： <a href="http://servername/Api/user/">http://servername/Api/user/</a>
订单接口： <a href="http://servername/Api/Order/">http://servername/Api/Order/</a></p>

<p>所以在 Yaf 中需要这样写。</p>

<p>Controller File:   /application/controllers/Api.php</p>

<pre><code>&lt;?php
class ApiController extends Yaf\Controller_Abstract
{
    /**
     * 会员接口
     * @return boolean
     */
    public function userAction()
    {
        $service = new Yar_Server(new \Api\User());
        $service-&gt;handle();
        return false;
    }
    /**
     *  订单接口
     *  @return boolean
     */
    public function orderAction()
    {
        $service = new Yar_Server(new \Api\Order());
        $service-&gt;handle();
        return false;
    }
}
</code></pre>

<p>以上我们的接口类文件指向了命令空间  \Api 下的  User 类 与 Order 类， 在Yaf 下需要如此定义。</p>

<p>User File:   /application/library/Api/User.php</p>

<pre><code>&lt;?php
/**
 * @date 2015-1-17
 * @author zhengyin &lt;zhengyin.name@gmail.com&gt;
 * @desc 会员对外接口
 */
namespace Api;
class User extends \IZY\Sys\ApiServer
{
    /**
     * 获取会员信息
     * @param int $userId   用户ID
     * return Array [会员信息]
     */
    public function getUserInfo($userId)
    {

        // ... 业务处理

        $data = array('userName'=&gt;'zhangsan','nickName'=&gt;'张三','regTime'=&gt;'2014-12-01 10:10:10');

        return $this-&gt;response(1,$data);
    }

}
</code></pre>

<p>Order File: /application/library/Api/Order.php</p>

<pre><code>&lt;?php
/**
 * @date 2015-1-17
 * @author zhengyin &lt;zhengyin.name@gmail.com&gt;
 * @desc 订单对外接口
 */
namespace Api;
class Order extends \IZY\Sys\ApiServer
{
    /**
     * 获取会员信息
     * @param int $orderId   订单ID
     * @param str $sign 签名
     * return Array [订单信息]
     */
    public function getOrderInfo($orderId,$sign)
    {
        //验证签名
        if(!$this-&gt;checkSign(func_get_args(),$sign)){
            return $this-&gt;response(0,array(
                    'code'=&gt;'SIGN_ERROR',
                    'errMsg'=&gt;'签名错误'
            ));
        }

        // ... 业务处理

        $data = array('orderId'=&gt;$orderId,'orderStatus'=&gt;'success');
        return $this-&gt;response(1, $data);
    }

}
</code></pre>

<p>这两个类文件都继承了命名空间  \IZY\Sys   ApiServer 类,这个类实际上是一些通用方法的封装</p>

<p>这个文件属于系统的核心文件，所以把它放在了 Yaf.ini 指定的 lib 下，这个根据具体指定而定，比如我的是:</p>

<p>yaf.library = /data/webroot/izhengyin/libs</p>

<p>内容如下:</p>

<pre><code>&lt;?php
namespace  IZY\Sys;
class ApiServer
{
    private static $signs = array(
            'sign1',
            'sign2'
            // .... 
    );
    /**
     * 验证签名
     * @param  $params 接口调用时的参数
     * @param  $sign   签名
     */
    protected function checkSign($params,$sign)
    {
        if(empty($sign)){
            return false;
        }
        ksort($params);
        $signStr = '';
        foreach($params as $key =&gt; $val)
        {
            if(empty($val) || $val == $sign) continue;
            $signStr .= $key.'='.$val.'&amp;';
        }
        $signStr = rtrim($signStr,'&amp;');
        foreach (self::$signs as $v){
            if(md5($signStr.$v) === $sign){
                return true;
            }
        }
        return false;
    }
    /**
     * 返回接口处理结果
     * @param  $status
     * @param  $data
     * @param  $other
     * return  Array [格式化好了的结果]
     */
    protected function response($status,$data,$other=array())
    {
        $response = array ();
        $response ['status'] = ( bool ) $status;
        $response ['data'] = $data;
        if (is_array ( $other ) &amp;&amp; ! empty ( $other )) {
            foreach ( $other as $k =&gt; $v ) {
                // 附加信息不能使用的键名
                if (! in_array ( $k, array (
                        'status',
                        'data'
                ) )) {
                    $response [$k] = $v;
                }
            }
        }
        return $response;
    }
}
</code></pre>

<p>简单的封装了两个方法，验证签名，和返回数据格式定义，实际上就是解决 数据安全校验，与数据格式定义问题。</p>

<p>完了以后写个测试文件，测试下。</p>

<p>test.php</p>

<pre><code>&lt;?php
    header('Content-type:text/html;charset=utf-8'); 
    $client = new Yar_Client(&quot;http://izhengyin.com/Api/User&quot;); 
    $result = $client-&gt;getUserInfo(10); 
    echo '&lt;pre&gt;'; 
    var_dump($result);
?&gt;
</code></pre>

<p>访问这个文件正常能看到  getUserInfo 的返回。</p>

<p>上面是 server 的一些封装，接下来看下， client 的封装</p>

<p>命名空间  \IZY\Sys   ApiClient 类</p>

<pre><code>&lt;?php
namespace  IZY\Sys;

class ApiClient
{
    private static $signs = array(
            'sign1',
            'sign2'
            // .... 
    );

    private $callBack;
    private $callNum=0;
    public function __construct()
    {

    }

    /**
     * 取得签名
     * @param  $params 接口调用时的参数
     */
    protected function getSign($params)
    {
        ksort($params);
        $signStr = '';
        foreach($params as $key =&gt; $val)
        {
            if(empty($val)) continue;
            $signStr .= $key.'='.$val.'&amp;';
        }
        $signStr = rtrim($signStr,'&amp;');
        return md5($signStr.self::$signs[mt_rand(0,count(self::$signs)-1)]);
    }
    /**
     * 调用服务端接口
     * @param  $server      Api server
     * @param  $api         接口
     * @param  $params      参数
     * @param  $openSign    开启签名
     * @param  $callBack    回调
     */ 
    public function call($server,$api,$params,$openSign=false,$callBack=null)
    {
        if($openSign){
            $params['sign'] = $this-&gt;getSign($params);
        }

        if($callBack === null){
            $client = new \Yar_Client(&quot;http://izhengyin.com/Api/User&quot;);
            return call_user_method_array($api, $client, $params);
        }
        $this-&gt;callNum ++;
        $this-&gt;callBack = $callBack;
        return \Yar_Concurrent_Client::call($server,$api,$params,array($this, 'ApiClientCallBack'));
    }
    /**
     * 执行并发调用
     */
    public function loop()
    {
        return \Yar_Concurrent_Client::loop(); 
    }
    /**
     * 并发调用回调
     * @param  $retval
     * @param  $callinfo
     */
    public function ApiClientCallBack($retval,$callinfo)
    {
        if($callinfo === null){
            return $this-&gt;callBack($retval,$callinfo);
        }
        static $data = array();
        $data[$callinfo['method']] = $retval;
        if(count($data) == $this-&gt;callNum){
            $fn = $this-&gt;callBack;
            return $fn($data,$callinfo);
        }
    }
}
</code></pre>

<p>这个类封装了，取得签名的方法，已经并发调用的方法,使用时类似于这样：</p>

<p>单个接口调用，并且不进行加密：</p>

<pre><code>&lt;?php 

class UserController extends Yaf\Controller_Abstract 
{ 
    public function getUserInfoAction() 
    { 
        $apiClinet = new \IZY\Sys\ApiClient();
        $userInfo = $apiClinet-&gt;call(&quot;http://izhengyin.com/Api/User&quot;, 'getUserInfo', array(10));
        var_dump($userInfo );
        return false; 
    } 
}
</code></pre>

<p>输出：</p>

<p>array(2) { [&ldquo;status&rdquo;]=&gt; bool(true) [&ldquo;data&rdquo;]=&gt; array(3) { [&ldquo;userName&rdquo;]=&gt; string(8) &ldquo;zhangsan&rdquo; [&ldquo;nickName&rdquo;]=&gt; string(6) &ldquo;张三&rdquo; [&ldquo;regTime&rdquo;]=&gt; string(19) &ldquo;2014-12-01 10:10:10&rdquo; }</p>

<p>多个接口调用并且却 getOrderInfo 进行加密：</p>

<pre><code>&lt;?php 

class UserController extends Yaf\Controller_Abstract 
{ 
    public function getUserInfoAction() 
    { 
        $apiClinet = new \IZY\Sys\ApiClient(); 
        function callback($data,$callinfo){ 
            var_dump($data); 
        } 
        $apiClinet-&gt;call(&quot;http://izhengyin.com/Api/User&quot;, 'getUserInfo', array(10),false,'callback'); 
        $apiClinet-&gt;call(&quot;http://izhengyin.com/Api/Order&quot;, 'getOrderInfo', array(10),true,'callback'); 
        $apiClinet-&gt;loop(); 
        return false; 
    } 
}
</code></pre>

<p>输出：</p>

<p>array(2) {
    [&ldquo;getOrderInfo&rdquo;]=&gt; array(2) { [&ldquo;status&rdquo;]=&gt; bool(true) [&ldquo;data&rdquo;]=&gt; array(2) { [&ldquo;ord erId&rdquo;]=&gt; int(10) [&ldquo;orderStatus&rdquo;]=&gt; string(7) &ldquo;success&rdquo; }
     }
    [&ldquo;getUserInfo&rdquo;]=&gt; array(2) { [&ldquo;status&rdquo;]=&gt; bool(true) [&ldquo;data&rdquo;]=&gt; array(3) { [&ldquo;userName&rdquo;]=&gt; string(8) &ldquo;zhangsan&rdquo; [&ldquo;nickName&rdquo;]=&gt; string(6) &ldquo;张三&rdquo; [&ldquo;regTime&rdquo;]=&gt; string(19) &ldquo;2014-12-01 10:10:10&rdquo; }
     }
 }</p>

<p>本文代码下载： <a href="http://izhengyin.com/downloads/izhengyin.zip">izhengyin.zip</a></p>

                    </div>
                </section>
                
            </div>
            

            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
            <li>Powered by <a class="hugo" href="http://hugo.spf13.com/" target="_blank">hugo</a></li>
        </ul>
    </div>
</div>
<script src="http://localhost:1313//js/all.min.js"></script>
        </div>
    </div>
</div>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-xxxxxx-xx', 'auto');
ga('send', 'pageview');

</script>

<script data-no-instant>document.write('<script src="http://'
        + (location.host || 'localhost').split(':')[0]
		+ ':1313/livereload.js?mindelay=10"></'
        + 'script>')</script></body>
</html>
